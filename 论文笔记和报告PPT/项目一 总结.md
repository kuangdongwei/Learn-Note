# 项目一 总结

经过一周左右的时间，完成了在公司实习的第一个项目。虽然项目需求比较简单，开发工作量也不是很大，但是在开发过程中还是碰到了一些问题，也从项目中学到了很多，从开发流程规范、解决问题的能力、编码能力和规范等多个方面都受益匪浅。下面是个人对本次项目开发的一些总结。

---



## 1 开发流程总结

通过本次项目，首先总结一下学到的项目开发大致流程吧：

- step 1：拿到需求后，对需求进行分析，分析需求是否有不合理的地方，是否有技术上行不通的需求细节等；
- step 2：根据合理的需求，弄清楚需求的业务流程，并画出业务流程图。如果需求需要拆分成多个模块，那么每个模块的业务流程图也需要详细地画出来；

- step 3：根据业务流程设计总体技术方案，如：技术调研和选型、架构设计、工作量和时间预估等；
- step 4： 分析需要哪些数据表、需要调用哪些远程服务接口，数据表的定义和创建，是否需要创建表索引及如何创建合理的索引；
- step 5：接口设计，定义需要哪些接口，每个接口的请求方式、类型、入参和响应内容；
- step 6：创建项目工程，编码开发，方法单元测试，所有接口开发完后对各个接口进行自测；
- step 7：打包发布到测试环境，与前端进行协作联调；
- step 8：将联调完善后的项目工程重新打包发布到测试环境，供测试对其进行测试，将测试阶段发现的bug修复，直到测试完全通过；
- step 9：将测试通过后的工程代码进行检查，确认无问题后发布到线上并对其进行初期的监测；
- step 10：迭代优化；

## 2 问题及经验总结

从最开始的demo实践学习到项目工程编码开发阶段碰到了很多的问题，包括从工程搭建、配置、编码实现细节、编译打包等方方面面都碰到了一些大大小小的问题，下面是问题和从问题中学到的经验的总结：

- 1 、在进行多模块Maven项目demo实践的时候，碰到了很多的模块引用冲突，包版本冲突的问题，感觉这一类问题有的时候比较难发现，所以父工程对子工程的管理，子工程引用子工程时，版本一定不能乱，还有就是多个模块不能引用同样的依赖包，不然Maven会在管理依赖包的时候不知道加载那个子工程中的依赖包从而出现问题；
- 2、在spring web 项目中，使用外置tomcat部署项目，在项目启动时经常会出现tomcat报错提示说spring 的xml配置文件中的命名空间中的某行...导致.....文件找不到的问题，后来查了资料后发现是spring framework的版本不一致的问题，需要将命名空间中的后缀版本去掉，改成http://........  .xsd，即将.xsd前面的版本号去掉，然后再启动项目的时候tomcat就不会报错了
- 3、在使用mybatis生成mapper、xml和model文件的时候，由于配置文件中包生成路径改变了导致新生成的文件与原来其他生成的文件不在一个包下面，那么这个时候就有多个mapper文件包，而service方法中调用了mapper接口，从而导致springboot在启动时容器扫描不到mapper文件报错，所以需要修改mybatis-generator配置文件重新生成使所有的mapper文件生成到一个包下。
- 4、在方案设计时由于订单号是根据日期有序生成和自增的且订单表中的订单号是唯一的，所以如何保证在多线程的情况下不会出现订单号重复是个需要解决的问题。根据自己的想法和大佬们的提示，确定主要有两种方案：1）可以使用redis缓存，每天0点生成一个date-maxOrderId的键值对，然后新生成订单的时候都先get当天的这个maxOrderId值，然后对其进行+1，再将新的订单插入到订单表中。这种方案的话事务不好控制，一个是更新redis，一个是更新数据库中的表；2）使用两张表。也是最终采用的方案，**大致思想如下：**每产生一个新的订单，都会先从该表根据日期查询出max_order的值，然后再在此值的基础上+1，一次作为本次新订单的订单号。为了保证一致性和线程安全，这里需要俩个策略：1）使用事务控制，即app_produce_orderid表中的新增或修改记录操作和在app_product_order表中新增订单记录这两个操作是一个事务；2）使用类CAS的操作保证多个线程同时产生订单的时候不会出现订单号重复的情况，即 while(update app_produce_orderid set max_order=新的orderid where max_order = 老的orderid == true)的时候再执行添加记录到app_product_order的操作（如果为false则将新的orderid替换掉老的orderid并且把新的ord+1）

> 但是个人感觉这种订单号生成方式在并发量大的情况下会严重影响性能影响用户体验，所以觉得这种订单号生成方式不怎么科学，个人觉得可以通过时间戳拼接随机数的方式生成新的订单号，这样基本上不会有订单号冲突，也不需要考虑上述的一致性、事务控制的问题。

- 5、在编程时发现mybatis生成的最常用的增删改查方法，在一些情况下不很好地能满足自己的业务需求，因此，花时间去读了官网的文档，熟悉了如何在mapper.xml文件中自定义crud方法，如何正确地使用trim、resultType和resultMap，如何灵活地根据数据表的字段变化来相应地修改文件；
- 6、在第一次测试的时候发现获取订单列表页面中没有分页，后面发现自己使用的查询方法是selectBy方法，这个方法是根据查询条件查询出所有的符合条件的记录并返回，后面改成了使用pageBy方法。而pageBy方法使用了PageHelper分页工具，该工具的原理是在查询的时候使用了limit条件，从而达到了物理分页的效果。当然，有物理分页就有逻辑分页，所谓逻辑分页就是后端查询出符合条件的所有记录然后全部返回给前端让前端去做分页，或者是后端在内存中分页后返回给前端。显然，在数据量大的情况下，逻辑分页的方法肯定是不科学的。
- 7、在更新订单记录的时候，应该先查后更新，要保证该记录存在的情况再去更新，从而避免不必要的更新操作和异常（因为在MySQL中查询的速度往往是比更新要快的，所以如果能够避免不必要的错误更新操作，那么就能可以进一步提升请求响应时间）
- 8、参数校验，根据需求，要对一些必传字段是否为空或格式进行校验，而校验的方式有好几种。可以直接在controller方法中手动校验和异常返回（这种方法会显得代码冗长混乱），也可以使用注解的方式校验（这也是目前主流的校验方式），即在entity中的属性上加上@notnull、notempty、email或maxLengh等注解和标注，然后在controller方法的参数中的@requestbody后面使用@validated校验注解。当然，controller层中处理参数校验异常外还有一些其他异常，这些异常都应该统一包装到自定义的全局异常处理器中。
- 9、在实际项目中，往往需要记录接口操作日志，并且把这些日志记录以结构化的数据形式持久化到关系数据库中，记录比如xxx在什么时间访问了那个接口，请求中传了什么参数等信息。可能最传统的方法就是在controller方法中从request中逐个获取到需要记录的信息字段，然后插入到数据库中。接口少的时候可以或许这样做还挺好，但是接口很多的时候这种方式导致的代码重复、冗长、工作量大等弊端就展露无遗。那么对于这种公共的重复逻辑工作，aop面向切面编程就可以大展身手了。在使用aop结合注解的方式进行接口操作日志记录的功能现时，由于不熟悉aop的使用、对连接点jointPoint，before和after等注解不够熟悉，导致自己一开始总尝试从HttpRequestServlet中去取请求参数，然后发现只能取到get请求方式中的请求参数，而取不到post请求的请求内容，然后查了包括HttpServletRequest相关官方文档和很多其他资料，也尝试了很多方式（比如从inputstream中转换，但是会报异常），最后向师兄求助，原来直接就在连接点中可以取到。后面自己通过查阅资料和打断点debug弄清楚了使用aop时其运转流程及相关注解的使用。
- 10、对HTTP的Content-Type类型不熟悉，后面自己查了，发现有很多种类型，但是最常用的也就那么那么几种。在定义接口的时候，一定要了解和使用正确的content-type，不然可能导致前端请求的content-type和后端代码中使用的不一致，从而前端总是请求不通，还误以为是自己的代码有问题。还有就是代码中的字段书写和接口中定义的字段书写一定要一致！不然可能导致前后端双方浪费不必要的时间在这低级bug上。
- 11、在查看内部框架部分代码或熟悉其他项目代码时，发现注释太少或者没有，因此有些地方看起来有些吃力。所以时常提醒和要求自己在写代码的时候养成随手写注释的习惯，也不耽误那点时间。



>总结一下解决问题的步骤：
>
>定位问题：控制台或日志查看报错或异常信息--->检测代码--->打断点debug跟踪
>
>解决问题：独立解决--->官方文档查阅--->百度谷歌--->请教大佬